# Decklin's (mostly) portable shrc
#
# I should be able to drop this in whether I have a ksh (preferred), an
# ash (just about any POSIX shell), or bash (many things here won't work
# as well as their incompatible improvements, but such is the way of all
# GNU software).

umask 002
ulimit -c unlimited

# If echo interprets -e, then it either requires it for backslash
# interpretation or eats it to appease broken implementations that
# do. Alternatively, we could define print in terms of echo, but then
# everything else would feel very ksh-centric.

if [ "$(echo -e)" != "-e" ]; then
    echo() { command echo -e "$@"; }
fi

# If it doesn't interpret -n, then we are screwed, and must fall back to
# printf, which is in most cases not a builtin. But it works.

if [ "$(echo -n)" = "-n" ]; then
    echo() {
        local end
        if [ "$1" = "-n" ]; then shift; else end='\n'; fi
        printf %b$end "$*"
    }
fi

# bash's POSIX mode will source ENV; but this file *is* ENV so before
# going posix we clear ENV to prevent it from running us twice.

if [ "$BASH_VERSION" ]; then
    unset ENV; set -o posix
fi

# THE MORE YOU KNOW: utf-8 is now old enough to be served in a pub. One
# would think more people might have gotten around to supporting it (DEC
# gets a pass here, obviously).

case $TERM in
    midpssh|xterm-color|vt100)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

# AT&T ksh, pdksh et al, and bash all have different history formats.
# tcsh probably has yet another. To prevent corrupting files, only set
# a history file for known shells. KSH_VERSION is pdksh and friends;
# ksh93 does not provide a usable test since its ${.sh.version} causes
# an unredirectable substitution error everywhere else.

if [ "$KSH_VERSION" ]; then
    export HISTFILE=$HOME/.ksh_history
    export FCEDIT=$EDITOR
    export HISTSIZE=9999
elif [ "$BASH_VERSION" ]; then
    export HISTFILE=$HOME/.bash_history
    export HISTOPTS=ignoreboth
    export HISTSIZE=9999
fi

# Fancy prompt. We never fork from PS1, assuming echo and kill are
# builtins. Everything else you want this for can be handled in cd() and
# some cleanup functions. In emergencies _fixtitle can be run manually.

PS1='$_host:! ${PWD##?*/}$_branch $(_status $?)$_ps1c '
_host=$(hostname -s)
_ps1c=$(test $(id -u) = 0 && echo '#' || echo '$')
_status() {
    if [ $1 -gt 128 ]; then
        echo -n "SIG$(kill -l $(($1-128))) "
    elif [ $1 -gt 0 ]; then
        echo -n "$1 "
    fi
}

# The xterm title and mercurial/git branch info tagged onto the pwd are
# only updated when we do something that might change their content.
# Except for cd, the list of these commands is necessarily incomplete;
# any command can overwrite our title and any command can dirty files
# checked into your VCS. It's a best-effort solution. I feel that
# occasionally having to tidy up is worth not constantly hitting the
# disk or redrawing a window frame.

cd() {
    command cd "$@" && _fixtitle && _fixbranch
}
_title() {
    echo -n "\033]0;$*\007"
}
_fixtitle() {
    if [ -t 1 ]; then
	case $TERM in
	    rxvt*|xterm*|screen)
		_title "${USER:=$(id -un)}@${HOSTNAME:=$(hostname)}: $PWD"
		;;
	esac
    fi
}
_fixbranch() {
    if [ -t 1 ]; then
	if [ "$(command hg id 2>/dev/null)" ]; then
	    _branch=":$(command hg id -b)/$(command hg id -n)"
	elif [ "$(command git rev-parse HEAD 2>/dev/null)" ]; then
	    _branch=":$(command git name-rev --name-only HEAD 2>/dev/null)"
	else
	    unset _branch
	fi
    fi
}

# FIXME: commands with dashes are not valid function names by POSIX. ksh
# allows it, but I'm not gonna kludge that with a test.

dirty='sh ash dash ksh mksh csh tcsh bash ssh vi screen mutt irssi hg git dch'

for i in $dirty; do
    eval "$i() { command $i \"\$@\"; _fixtitle; }";
done
for i in hg git; do
    eval "$i() { command $i \"\$@\"; _fixbranch; }"
done

unset dirty
unset i

# Operating system junk. As they say, the wonderful thing about
# standards is that there are so many to choose from.

case $(uname) in
    *BSD)
        export CLICOLOR=1
        ;;
    Linux)
        export PAGER=less
        _ls_color=' --color'
        ;;
esac

# Personal aliases and functions.

alias j=jobs
alias h='fc -l'
alias g='egrep -i'
alias gh='h 1 | g'
alias lc="ls -h$_ls_color"
alias ll="ls -hl$_ls_color"
alias la="ls -hlA$_ls_color"
alias lr="ls -hlrt$_ls_color"
alias l=ll
alias m=$PAGER

alias sr='screen -D -R'
alias duh='du -Dshx'
alias bcl='bc -lq'
alias mpn='mplayer -nosound'
alias muff='mutt -f'
alias my='mutt -y'
alias ds='pee diffstat colordiff | ${PAGER:-sensible-pager}'
alias glog='hg glog --style compact | ${PAGER:-sensible-pager}'
alias lsmp3="mp3info -r a -p '%8.2r %3m:%02s %f\n'"
alias na='normalize-audio'
alias rec44='rec -c 2 -s w -r 44100'
alias rot13="tr '[a-zA-Z]' '[n-za-mN-ZA-M]'"
alias vt='TERM=vt100wy LANG=C LC_ALL=C'
alias apt-yes-please="r 'apt-cache show'='sudo apt-get install'"

dua() { du -Dsx "$@" | perl -alne '$s+=$F[0];END{print $s/1024}'; }

# ksh redefines this. Yuck. I can just use 'builtin rename' for the
# builtin.

rename() { command rename "$@"; };

# I am insane, and normally run with an unwritable home dir to keep
# myself from littering it with useless files and programs from creating
# unapproved dotfiles. I have found lots of fun bugs this way.

modhome() { chmod +w $HOME; "$@"; chmod -w $HOME; }

# Crude approximations of stuff that I keep forgetting I don't have on
# one system or the other.

command -v par >/dev/null 2>&1 || par() { fmt "$@"; }
command -v seq >/dev/null 2>&1 || seq() { jot $(($2-$1+1)) $1; }

# Now we get to interactive-and-terminal-specific stuff

case "$-" in
    *i*)
        if [ -t 1 ]; then
            test -x /usr/games/fortune && /usr/games/fortune -s
            set -o emacs; _fixtitle; _fixbranch
        fi
        ;;
esac

# Maybe override or add private settings. Finally, clear exit status for
# the sake of our prompt.

test -f $HOME/.shrc.local && . $HOME/.shrc.local || :
