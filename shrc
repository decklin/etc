# Decklin's (mostly) portable shrc
#
# I should be able to drop this in whether I have a ksh (preferred), an
# ash (just about any POSIX shell), or bash (many things here won't work
# as well as their incompatible improvements, but such is the way of all
# GNU software).
#
# Any variables or functions only meant to be used internally should
# start with a leading underscore or (for variables) be function-local.

umask 002
ulimit -c unlimited

# If echo interprets -e, then it either requires it for backslash
# interpretation or eats it to appease broken implementations that
# do. Alternatively, we could define print in terms of echo, but then
# everything else would feel very ksh-centric.

if [ "$(command echo -e)" != "-e" ]; then
    echo() { command echo -e "$@"; }
fi

# If it doesn't interpret -n, then we are screwed, and must fall back to
# printf, which is in most cases not a builtin. But it works.

if [ "$(echo -n)" = "-n" ]; then
    echo() {
        local n=''
        if [ "$1" = "-n" ]; then shift; else n='\n'; fi
        printf "%b$n" "$*"
    }
fi

# THE MORE YOU KNOW: utf-8 is now old enough to be served in a pub. One
# would think more people might have gotten around to supporting it (DEC
# gets a pass here, obviously).

case $TERM in
    midpssh|xterm-color|vt100)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

# AT&T ksh, pdksh et al, and bash all have different history formats.
# tcsh probably has yet another. To prevent corrupting files, only set
# a history file for known shells. KSH_VERSION is pdksh and friends;
# ksh93 does not provide a usable test since its ${.sh.version} causes
# an unredirectable substitution error everywhere else.
#
# We assume here (and later on) that any shell that does support saving
# history uses HISTFILE for the file name.

_first() { local n c; read n c && echo "$n"; }

if [ "$KSH_VERSION" ]; then
    HISTFILE=$HOME/.ksh_history
    _hist_last() { fc -l -1 | _first; }
elif [ "$BASH_VERSION" ]; then
    HISTFILE=$HOME/.bash_history
    HISTOPTS=ignoreboth
    _hist_last() { history 1 | _first; }
else
    unset HISTFILE
fi

if [ "$HISTFILE" ]; then
    HISTSIZE=10000
    _hist_warn=9500
fi

# Fancy prompt. If we have a capable terminal the title will be reset
# every time; otherwise do nothing. In most directories this should not
# fork at all (assuming echo and kill are builtins). We only check the
# branch if cd'ing into the pwd found a supported VCS.

if [ -t 1 ]; then
    # Currently, _user and _fqdn are only used if we can set a window
    # title, but you never know.
    _user=$(id -un)
    _host=$(hostname -s)
    _fqdn=$(hostname -f)

    case $TERM in
    rxvt*|xterm*|screen*)
        # Also: sigh. We should be able to use $(tput tsl) and $(tput
        # fsl) here. But no, hardcoded escapes, which have to be
        # interpreted before going into PS1 (the shell does a couple
        # types of expansion there, but that is not one of them).
        _ht_on=$(echo -n '\033]0;')
        _ht_off=$(echo -n '\007')
        _hard_title() {
            echo -n "$_user@$_fqdn - ${_branch:+$_branch on }$PWD";
        }
        if [ "$KSH_VERSION" ]; then
            _ign_pre=''
            _ign_on=''
            _ign_off=''
        elif [ "$BASH_VERSION" ]; then
            _ign_on='\['
            _ign_off='\]'
        fi
        _ht="$_ign_on$_ht_on"'$(_hard_title)'"$_ht_off$_ign_off"
        ;;
    esac
fi

_ps0='$_host:$_pwd${_branch:+[$_branch]} $(_hist_n)$(_status $?)'
_ps1="$(test "$(id -u)" = 0 && echo '#' || echo '\$') "

PS1="$_ign_pre$_ps0$_ht$_ps1"

cd() { command cd "$@" && _check_pwd && _check_branch; }
git() { command git "$@" && _check_branch; }
hg() { command hg "$@" && _check_branch; }

_check_pwd() {
    unset _vcs _branch
    if command hg id >/dev/null 2>&1; then
        _vcs=hg
    elif command git rev-parse HEAD >/dev/null 2>&1; then
        _vcs=git
    fi
    case "$PWD" in
        $HOME) _pwd="~";;
        /) _pwd="$PWD";;
        *) _pwd="${PWD##*/}";;
    esac
}

_check_branch() {
    case "$_vcs" in
        hg)
            _branch="$(command hg id -b)@$(command hg id -n)";;
        git)
            local h="$(command git symbolic-ref -q HEAD)"
            if [ "$h" ]; then
                _branch="${h##*/}"
            else
                h="$(command git describe --all --contains --always HEAD)"
                _branch="${h#remotes/}"
            fi;;
    esac
}

_hist_n() {
    if [ "$HISTFILE" ]; then
        local n="$(_hist_last)"
        if [ "$n" -gt "$_hist_warn" ]; then echo "#$n "; fi
    fi
}

_status() {
    if [ $1 -gt 128 ]; then
        echo "$(kill -l $(($1-128)))! "
    elif [ $1 -gt 0 ]; then
        echo "$1! "
    fi
}

# Operating system junk. As they say, the wonderful thing about
# standards is that there are so many to choose from.

case $(uname) in
    *BSD)
        export CLICOLOR=1
        ;;
    *Linux)
        _ls_color=' --color'
        ;;
esac

# Personal aliases and functions. Normally, my $EDITOR is already 'e',
# but this is here to preserve muscle-memory if I need to change it.

alias e='$EDITOR'
alias j='jobs'
alias h='fc -l'
alias g='egrep -i'
alias gh='h 1 | g'
alias lc="ls -h$_ls_color"
alias ll="ls -hl$_ls_color"
alias la="ls -hlA$_ls_color"
alias lr="ls -hlrt$_ls_color"
alias l='ll'
alias m='$PAGER'
alias se='sudoedit'

alias sr='screen -D -R'
alias ta='tmux attach'
alias duh='du -Dshx'
alias dm='pee diffstat colordiff | $PAGER'
alias bcl='bc -lq'
alias mpn='mplayer -nosound'
alias muff='mutt -f'
alias my='mutt -y'
alias slog='hg log -q -l 10'
alias glog='hg glog | $PAGER'
alias lsmp3='mp3info -r a -p "%8.2r %3m:%02s %f\n"'
alias na='normalize-audio'
alias rec44='rec -c 2 -s w -r 44100'
alias rot13='tr "[a-zA-Z]" "[n-za-mN-ZA-M]"'
alias vt='TERM=vt100wy LANG=C LC_ALL=C'

dua() { du -Dsx "$@" | perl -alne '$s+=$F[0];END{print $s/1024}'; }
md() { mkdir -p "$@" && cd "$@"; }
rs() { ssh -t "$@" screen -D -R; }
rt() { ssh -t "$@" tmux attach; }
shot() { xwd "$@" | xwdtopnm | pnmtopng; }

hr() {
    local i
    for i in $(seq $COLUMNS); do echo -n -; done
    for i in $(seq $(($LINES - 1))); do echo; done
}

# ksh redefines this. Yuck. I can just use 'builtin rename' for the
# builtin.

_ren=$(which rename)
rename() { $_ren "$@"; };

# I am insane, and sometimes run with an unwritable home dir to keep
# myself from littering it with useless files and programs from creating
# unapproved dotfiles. I have found lots of fun bugs this way.

modhome() { chmod +w $HOME; "$@"; chmod -w $HOME; }

# Crude approximations of stuff that I keep forgetting I don't have on
# one system or the other.

command -v par >/dev/null 2>&1 || par() { fmt "$@"; }
command -v seq >/dev/null 2>&1 || seq() { jot $(($2-$1+1)) $1; }

# Now we get to interactive-and-terminal-specific stuff

case "$-" in
    *i*)
        if [ -t 1 ]; then
            test -x /usr/games/fortune && /usr/games/fortune -s
            set -o emacs
        fi
        _check_pwd
        _check_branch
        ;;
esac

# Maybe override or add private settings.

if [ -f $HOME/.shrc.local ]; then . $HOME/.shrc.local; fi
