# Decklin's (mostly) portable shrc
#
# I should be able to drop this in whether I have a ksh (preferred), an
# ash (just about any POSIX shell), or bash (many things here won't work
# as well as their incompatible improvements, but such is the way of all
# GNU software).
#
# Any variables or functions only meant to be used internally should
# start with a leading underscore or (for variables) be function-local.

umask 002
ulimit -c unlimited

# If echo interprets -e, then it either requires it for backslash
# interpretation or eats it to appease broken implementations that
# do. Alternatively, we could define print in terms of echo, but then
# everything else would feel very ksh-centric.

if [ "$(echo -e)" != "-e" ]; then
    echo() { command echo -e "$@"; }
fi

# If it doesn't interpret -n, then we are screwed, and must fall back to
# printf, which is in most cases not a builtin. But it works.

if [ "$(echo -n)" = "-n" ]; then
    echo() {
        local end
        if [ "$1" = "-n" ]; then shift; else end='\n'; fi
        printf %b$end "$*"
    }
fi

# bash's POSIX mode will source ENV; but this file *is* ENV so before
# going posix we clear ENV to prevent it from running us twice.

if [ "$BASH_VERSION" ]; then
    unset ENV; set -o posix
fi

# THE MORE YOU KNOW: utf-8 is now old enough to be served in a pub. One
# would think more people might have gotten around to supporting it (DEC
# gets a pass here, obviously).

case $TERM in
    midpssh|xterm-color|vt100)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

# AT&T ksh, pdksh et al, and bash all have different history formats.
# tcsh probably has yet another. To prevent corrupting files, only set
# a history file for known shells. KSH_VERSION is pdksh and friends;
# ksh93 does not provide a usable test since its ${.sh.version} causes
# an unredirectable substitution error everywhere else.

# FIXME: the history size should be customizable, but we haven't read
# .shrc.local yet. Need a sane solution.

_hist_size=10000

if [ "$KSH_VERSION" ]; then
    export HISTFILE=$HOME/.ksh_history
    export HISTSIZE=$_hist_size
    export FCEDIT=$EDITOR
elif [ "$BASH_VERSION" ]; then
    export HISTFILE=$HOME/.bash_history
    export HISTSIZE=$_hist_size
    export HISTOPTS=ignoreboth
fi

# Fancy prompt. If we have a capable terminal the title will be reset
# every time; otherwise do nothing. In most directories this should not
# fork at all (assuming echo and kill are builtins). We only check the
# branch if cd'ing into the pwd found a supported VCS.

if [ -t 1 ]; then case $TERM in
    rxvt*|xterm*|screen)
        _user=$(id -un)
        _host=$(hostname)
        _t_start=$(echo -n "\033]0;")
        _t_end=$(echo -n "\007")
        _print_title() {
            echo -n "$_user@$_host - $(_branch)$PWD ($(date '+%H:%M'))";
        }
        if [ "$KSH_VERSION" ]; then
            _title='$_t_start$(_print_title) #!$_t_end'
        elif [ "$BASH_VERSION" ]; then
            _title='\[$_t_start$(_print_title) #!$_t_end\]'
        fi
        ;;
    esac
fi

PS1="$_title"'$(_status $?)'"$(test $(id -u) = 0 && echo '# ' || echo '$ ')"

cd() {
    command cd "$@" && _check_vcs
}

_check_vcs() {
    unset _vcs
    if command hg id >/dev/null 2>&1; then
        _vcs=hg
    elif command git rev-parse HEAD >/dev/null 2>&1; then
        _vcs=git
    fi
}

_branch() {
    if [ "$_vcs" = hg ]; then
        echo "$(command hg id -b) at $(command hg id -n) on"
    elif [ "$_vcs" = git ]; then
        echo "$(command git name-rev --name-only HEAD 2>/dev/null) on "
    fi
}

_status() {
    if [ $1 -gt 128 ]; then
        echo "[exit: $(kill -l $(($1-128)))] "
    elif [ $1 -gt 0 ]; then
        echo "[exit: $1] "
    fi
}

# Operating system junk. As they say, the wonderful thing about
# standards is that there are so many to choose from.

case $(uname) in
    *BSD)
        export CLICOLOR=1
        ;;
    *Linux)
        _ls_color=' --color'
        ;;
esac

# Personal aliases and functions. Normally, my $EDITOR is already 'e',
# but this is here to preserve muscle-memory if I need to change it.

alias e='$EDITOR'
alias j='jobs'
alias h='fc -l'
alias g='egrep -i'
alias gh='h 1 | g'
alias lc="ls -h$_ls_color"
alias ll="ls -hl$_ls_color"
alias la="ls -hlA$_ls_color"
alias lr="ls -hlrt$_ls_color"
alias l='ll'
alias m='$PAGER'
alias se='sudoedit'

alias sr='screen -D -R'
alias duh='du -Dshx'
alias dm='pee diffstat colordiff | $PAGER'
alias bcl='bc -lq'
alias mpn='mplayer -nosound'
alias muff='mutt -f'
alias my='mutt -y'
alias slog='hg log -q -l 10'
alias glog='hg glog | $PAGER'
alias lsmp3='mp3info -r a -p "%8.2r %3m:%02s %f\n"'
alias na='normalize-audio'
alias rec44='rec -c 2 -s w -r 44100'
alias rot13='tr "[a-zA-Z]" "[n-za-mN-ZA-M]"'
alias vt='TERM=vt100wy LANG=C LC_ALL=C'

dua() { du -Dsx "$@" | perl -alne '$s+=$F[0];END{print $s/1024}'; }
md() { mkdir -p "$@" && cd "$@"; }
rs() { ssh -t "$@" screen -D -R; }
shot() { xwd "$@" | xwdtopnm | pnmtopng; }

hr() {
    for i in $(seq $COLUMNS); do echo -n -; done
    for i in $(seq $(($LINES - 1))); do echo; done
}

# ksh redefines this. Yuck. I can just use 'builtin rename' for the
# builtin.

_ren=$(which rename)
rename() { $_ren "$@"; };

# I am insane, and sometimes run with an unwritable home dir to keep
# myself from littering it with useless files and programs from creating
# unapproved dotfiles. I have found lots of fun bugs this way.

modhome() { chmod +w $HOME; "$@"; chmod -w $HOME; }

# Crude approximations of stuff that I keep forgetting I don't have on
# one system or the other.

command -v par >/dev/null 2>&1 || par() { fmt "$@"; }
command -v seq >/dev/null 2>&1 || seq() { jot $(($2-$1+1)) $1; }

# Now we get to interactive-and-terminal-specific stuff

case "$-" in
    *i*)
        if [ -t 1 ]; then
            test -x /usr/games/fortune && /usr/games/fortune -s
            set -o emacs
        fi
        _check_vcs
        ;;
esac

# Maybe override or add private settings. Finally, clear exit status for
# the sake of our prompt.

test -f $HOME/.shrc.local && . $HOME/.shrc.local || :
