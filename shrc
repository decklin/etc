# Decklin's (mostly) portable shrc
#
# I should be able to drop this in whether I have a ksh (preferred), an
# ash (just about any POSIX shell), or bash (many things here won't work
# as well as their incompatible improvements, but such is the way of all
# GNU software).

umask 002
ulimit -c unlimited

# If echo interprets -e, then it either requires it for backslash
# interpretation or eats it to appease broken implementations that
# do. Alternatively, we could define print in terms of echo, but then
# everything else would feel very ksh-centric.

if [ "$(echo -e)" != "-e" ]; then
    echo() { command echo -e "$@"; }
fi

# If it doesn't interpret -n, then we are screwed, and must fall back to
# printf, which is in most cases not a builtin. But it works.

if [ "$(echo -n)" = "-n" ]; then
    echo() {
        local end
        if [ "$1" = "-n" ]; then shift; else end='\n'; fi
        printf %b$end "$*"
    }
fi

# bash's POSIX mode will source ENV; but this file *is* ENV so before
# going posix we clear ENV to prevent it from running us twice.

if [ "$BASH_VERSION" ]; then
    unset ENV; set -o posix
fi

# THE MORE YOU KNOW: utf-8 is now old enough to be served in a pub. One
# would think more people might have gotten around to supporting it (DEC
# gets a pass here, obviously).

case $TERM in
    midpssh|xterm-color|vt100)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

# AT&T ksh, pdksh et al, and bash all have different history formats.
# tcsh probably has yet another. To prevent corrupting files, only set
# a history file for known shells. KSH_VERSION is pdksh and friends;
# ksh93 does not provide a usable test since its ${.sh.version} causes
# an unredirectable substitution error everywhere else.

if [ "$KSH_VERSION" ]; then
    export HISTFILE=$HOME/.ksh_history
    export FCEDIT=$EDITOR
    export HISTSIZE=9999
elif [ "$BASH_VERSION" ]; then
    export HISTFILE=$HOME/.bash_history
    export HISTOPTS=ignoreboth
    export HISTSIZE=9999
fi

# Fancy prompt. If we have a capable terminal the title will be reset
# every time; otherwise do nothing. In most directories this should not
# fork at all (assuming echo and kill are builtins). We only check the
# branch if cd'ing into the pwd found a supported VCS.

if [ "$KSH_VERSION" ]; then
    _titlehook='$(_pwdtitle)'
elif [ "$BASH_VERSION" ]; then
    _titlehook='\[$(_pwdtitle)\]'
fi

PS1="$_titlehook"'$_host:${PWD##?*/}$(_branch) $(_status $?)$_ps1c '

_ps1c=$(test $(id -u) = 0 && echo '#' || echo '$')
_user=$(id -un)
_host=$(hostname -s)
_fullhost=$(hostname)
_pwdtitle() { :; }

if [ -t 1 ]; then case $TERM in
    rxvt*|xterm*|screen)
        _title() { echo -n "\033]0;$*\007"; }
        _pwdtitle() { _title "$_user@$_fullhost: $PWD"; }
        ;;
    esac
fi

cd() {
    command cd "$@" && _check_vcs
}
    
_check_vcs() {
    unset _vcs
    if command hg id >/dev/null 2>&1; then
        _vcs=hg
    elif command git rev-parse HEAD >/dev/null 2>&1; then
        _vcs=git
    fi
}

_branch() {
    if [ "$_vcs" = hg ]; then
        echo ":$(command hg id -b):$(command hg id -n)"
    elif [ "$_vcs" = git ]; then
        echo ":$(command git name-rev --name-only HEAD 2>/dev/null)"
    fi
}

_status() {
    if [ $1 -gt 128 ]; then
        echo -n "$(kill -l $(($1-128))) "
    elif [ $1 -gt 0 ]; then
        echo -n "$1 "
    fi
}

# Operating system junk. As they say, the wonderful thing about
# standards is that there are so many to choose from.

case $(uname) in
    *BSD)
        export CLICOLOR=1
        ;;
    Linux)
        export PAGER=less
        _ls_color=' --color'
        ;;
esac

# Personal aliases and functions.

alias j=jobs
alias h='fc -l'
alias g='egrep -i'
alias gh='h 1 | g'
alias lc="ls -h$_ls_color"
alias ll="ls -hl$_ls_color"
alias la="ls -hlA$_ls_color"
alias lr="ls -hlrt$_ls_color"
alias l=ll
alias m=$PAGER

alias sr='screen -D -R'
alias duh='du -Dshx'
alias bcl='bc -lq'
alias mpn='mplayer -nosound'
alias muff='mutt -f'
alias my='mutt -y'
alias md='pee diffstat colordiff | $PAGER'
alias slog='hg log -q -l 10'
alias glog='hg glog | $PAGER'
alias lsmp3="mp3info -r a -p '%8.2r %3m:%02s %f\n'"
alias na='normalize-audio'
alias rec44='rec -c 2 -s w -r 44100'
alias rot13="tr '[a-zA-Z]' '[n-za-mN-ZA-M]'"
alias vt='TERM=vt100wy LANG=C LC_ALL=C'
alias apt-yes-please="r 'apt-cache show'='sudo apt-get install'"

dua() { du -Dsx "$@" | perl -alne '$s+=$F[0];END{print $s/1024}'; }
rscr() { ssh -t "$@" screen -D -R; }
shot() { xwd "$@" | xwdtopnm | pnmtopng; }

# ksh redefines this. Yuck. I can just use 'builtin rename' for the
# builtin.

_ren=$(which rename)
rename() { $_ren "$@"; };

# I am insane, and normally run with an unwritable home dir to keep
# myself from littering it with useless files and programs from creating
# unapproved dotfiles. I have found lots of fun bugs this way.

modhome() { chmod +w $HOME; "$@"; chmod -w $HOME; }

# Crude approximations of stuff that I keep forgetting I don't have on
# one system or the other.

command -v par >/dev/null 2>&1 || par() { fmt "$@"; }
command -v seq >/dev/null 2>&1 || seq() { jot $(($2-$1+1)) $1; }

# Now we get to interactive-and-terminal-specific stuff

case "$-" in
    *i*)
        if [ -t 1 ]; then
            test -x /usr/games/fortune && /usr/games/fortune -s
            set -o emacs
        fi
        _check_vcs
        ;;
esac

# Maybe override or add private settings. Finally, clear exit status for
# the sake of our prompt.

test -f $HOME/.shrc.local && . $HOME/.shrc.local || :
