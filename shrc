# Decklin's (mostly) portable shrc
#
# I should be able to drop this in whether I have ksh (preferred), ash
# (just about any POSIX shell), or bash (many things here won't work as
# well as their incompatible improvements, but such is the way of all
# GNU software).

# System quirks and overrides. bash's POSIX mode will source ENV; but
# this file *is* ENV so before going posix we must clear ENV to prevent
# it from running us twice.

if [ "$BASH_VERSION" ]; then
    unset ENV; set -o posix
fi

# ksh and bash have the -e hack, and in the case of ksh93 and bash, require
# it for backslash interpretation.

if [ "$(echo -e)" != "-e" ]; then
    echo() { command echo -e "$@"; }
fi

case $TERM in
    midpssh|xterm-color|vt100*)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

case $(uname) in
    *BSD)
        export CLICOLOR=1
        ;;
    Linux)
        export PAGER=less
        _ls_color=' --color'
        ;;
esac

# Real ksh, pdksh et al, and bash all have different history formats.
# tcsh probably has yet another. ksh93 and pdksh are binary and sorta
# similar but have different magic. mksh (as of R33) has a bug where
# attempting to read a ksh93 histfile will throw it into an infinite
# loop on startup.
#
# pdksh et al and bash set a variable to declare their version to the
# world, so we will use those to override the default of .sh_history.
# Each file *is* compatible between (on one hand) pdksh, mksh, and
# OpenBSD ksh, and (on the other) all versions of bash.
#
# In practice this means .sh_history will be in ksh93 cooked format, so
# if someone decides to add history persistence to an ash derivative, it
# will probably choke. I'll deal with that when it happens.

export FCEDIT=$EDITOR
export HISTFILE=$HOME/.sh_history
export HISTSIZE=9999

if [ "$KSH_VERSION" ]; then
    export HISTFILE=$HOME/.pdksh_history
elif [ "$BASH_VERSION" ]; then
    export HISTFILE=$HOME/.bash_history
fi

# Fancy prompt. We never fork from PS1, assuming echo and kill are
# builtins. Everything else you want this for can be handled in cd() and
# some cleanup functions. In emergencies _fixtitle can be run manually.

PS1='$_host:! ${PWD##?*/}$_branch $(_status $?)$_ps1c '
_host=$(hostname -s)
_ps1c=$(test $(id -u) = 0 && echo '#' || echo '$')
_status() {
    if [ $1 -gt 128 ]; then
        echo -n "SIG$(kill -l $(($1-128))) "
    elif [ $1 -gt 0 ]; then
        echo -n "$1 "
    fi
}

cd() {
    command cd "$@"
    _fixtitle
    _fixbranch
}
_title() {
    echo -n "\033]0;$*\007"
}
_fixtitle() {
    case $TERM in
        rxvt*|xterm*|screen)
            _title "${USER:=$(id -un)}@${HOSTNAME:=$(hostname)}: $PWD"
            ;;
    esac
}
_fixbranch() {
    if [ "$(command hg id 2>/dev/null)" ]; then
        _branch=":$(command hg id -b):$(command hg id -n)"
    elif [ "$(command git rev-parse HEAD 2>/dev/null)" ]; then
        _ref=$(command git symbolic-ref HEAD 2>/dev/null)
        _branch=":${_ref#refs/heads/}"
    else
        unset _branch
    fi
}

# FIXME: commands with dashes are not valid function names by POSIX. ksh
# allows it, but I'm not gonna kludge that with a test.

for i in sh ash dash ksh mksh csh tcsh bash ssh vim screen mutt irssi hg git \
        dch; do
    eval "$i() { command $i \"\$@\"; _fixtitle; }";
done
for i in hg git; do
    eval "$i() { command $i \"\$@\"; _fixbranch; }"
done
unset i

# User aliases and functions.

alias j=jobs
alias h='fc -l'
alias g='egrep -i'
alias gh='h 1 | g'
alias l="ls -hl$_ls_color"
alias ll="ls -hla$_ls_color"
alias la="ls -hlA$_ls_color"
alias lc="ls $_ls_color"
alias m=$PAGER

alias sr='screen -D -R'
alias duh='du -Dshx'
alias bcl='bc -lq'
alias mpn='mplayer -nosound'
alias muff='mutt -f'
alias my='mutt -y'
alias diffspy='pee diffstat colordiff | ${PAGER:-sensible-pager}'
alias glog='hg glog --style compact | ${PAGER:-sensible-pager}'
alias lsmp3="mp3info -r a -p '%8.2r %3m:%02s %f\n'"
alias na='normalize-audio'
alias rec44='rec -c 2 -s w -r 44100'
alias rot13="tr '[a-zA-Z]' '[n-za-mN-ZA-M]'"
alias vt='TERM=vt100wy LANG=C LC_ALL=C'
alias apt-yes-please="r 'apt-cache show'='sudo apt-get install'"

# ksh redefines this. Yuck. I can use 'builtin rename' for the builtin.

rename() { command rename "$@"; };

# I am insane, and normally run with an unwritable home dir to keep
# myself from littering it with useless files and programs from creating
# unapproved dotfiles. I have found lots of fun bugs this way.

modhome() { chmod +w $HOME; "$@"; chmod -w $HOME; }

# Crude approximations of stuff that I keep forgetting I don't have on
# one system or the other.

command -v par >/dev/null 2>&1 || par() { fmt "$@"; }
command -v seq >/dev/null 2>&1 || seq() { jot $(($2-$1+1)) $1; }

# And finally interactive-and-terminal-specific stuff

case "$-" in
    *i*)
        if [ -t 1 ]; then
            test -x /usr/games/fortune && /usr/games/fortune -sa
            set -o emacs; _fixtitle; _fixbranch
        fi
        ;;
esac

# Maybe override or add private settings.

test -f $HOME/.shrc.local && . $HOME/.shrc.local

# Aaaaand clear exit status for the sake of our prompt.

:
