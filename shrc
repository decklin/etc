# This file shouldn't contain much. Most customization is only needed
# for interactive shells.

umask 002
ulimit -c unlimited

# Set up PATH (use this function for your additional paths in .shrc.local)

_add_path() {
    for dir; do
        test -d "$dir" -a "${PATH##*$dir:}" = "$PATH" && PATH="$dir:$PATH"
    done
}

_add_path /usr/local/share/npm/bin
_add_path /var/lib/gems/*/bin
_add_path $HOME/.gem/ruby/*/bin
_add_path $HOME/Library/Haskell/bin
_add_path $HOME/.cabal/bin
_add_path $HOME/.lein/bin
_add_path $HOME/proj/harvard/anl-utils
_add_path $HOME/proj/decklin/bin
_add_path $HOME/.local/bin
_add_path $HOME/bin

# Ensure custom TMPDIR existence

test -d "$TMPDIR" || mkdir -p "$TMPDIR"

# I used to use some terminals that didn't support UTF-8. This should
# probably go somewhere else.

case $TERM in
    midpssh|vt100)
        export LANG=en_US.ISO-8859-1
        export LC_CTYPE=en_US.ISO-8859-1
        export LC_MESSAGES=en_US.ISO-8859-1
        export LC_MONETARY=en_US.ISO-8859-1
        export LC_NUMERIC=en_US.ISO-8859-1
        export LESSCHARSET=latin1
        export MANFMT=latin1
        ;;
esac

# Operating system junk. As they say, the wonderful thing about
# standards is that there are so many to choose from.

case $(uname) in
    *BSD|Darwin)
        export CLICOLOR=1
        export LSCOLORS='exfxcxdxbxegedabagacad'
        ;;
    *Linux)
        test -e "$HOME/.dircolors" && eval "$(dircolors $HOME/.dircolors)"
        _ls_color=' --color -N'
        ;;
esac

# Load interactive stuff if we're on a terminal.

case "$-" in
    *i*) test -t 1 && . $HOME/.shrc.interactive;;
esac

# Add aliases, maybe override or add private settings.

test -f $HOME/.shrc.aliases && . $HOME/.shrc.aliases
test -f $HOME/.shrc.local && . $HOME/.shrc.local

# Clear exit status.

:
